// We require the Hardhat Runtime Environment (HRE, containing ETHERS and WAFFLE) explicitly here. This is optional
// but useful for running the script in a standalone fashion through `node <script>`.
//
// When running the script with `npx hardhat run <script>` you'll find the Hardhat
// Runtime Environment's members available in the global scope.

const { ethers, waffle} = require("hardhat");
const { writeFileSync, copyFile } = require("fs");

//paths to store the content generated by the deployment process
let relativeAddressFilePath='./src/bankContractAddress.js';
let relativeAbiFilePath='./artifacts/contracts/Bank.sol/Bank.json';
let relativeAbiFileNewPath='./src/abis/bankContractAbi.json'
let bankContractObject;

//get the waffle provider
let provider=waffle.provider;

async function deploy() {
  //get the first 2 addresses on the blockchain (Ethers handles this, only for development purposes)
  const [owner, randomPerson] = await ethers.getSigners();

  // Hardhat always runs the compile task when running scripts with its command
  // line interface.
  //
  // If this script is run directly using `node` you may want to call compile
  // manually to make sure everything is compiled
  // await hre.run('compile');


  // We get the contract to deploy
  const bankContract = await ethers.getContractFactory("Bank");

  // Deploy it with an initial 0.001 ETH balance
  bankContractObject = await bankContract.deploy({
    value: ethers.utils.parseEther("0.1"),
  });

  // Await for the blockchain to confirm deployment
  await bankContractObject.deployed();
  // Contract successfully deployed to contract address
  console.log("Contract deployed by:", owner.address);
  console.log("Bank deployed to:", bankContractObject.address);

  //excute post-deployment file operations
  writeToFile(bankContractObject.address);
  copyContractFile();

  //get the balance of the deployed contract
  let currentBalance=await provider.getBalance(bankContractObject.address);
  console.log(`Bank balance in ETH: ${ethers.utils.formatEther(currentBalance)} ETH`);
  console.log("Rinkeby testnet etherscan URL is: "+"https://rinkeby.etherscan.io/address/"+bankContractObject.address)
  return true;
}

// write the contract address to the file where the react app reads it fromt
async function writeToFile(contractAddress){
  let contractJs = `export const contractAddress = "${contractAddress}" \nexport default contractAddress`;
  writeFileSync(relativeAddressFilePath, contractJs, (err) => {
    if (err){
      console.log(err)
      throw err
    }
    console.log(`Content: ${contractJs} written to file: ${relativeAddressFilePath}`)
  });
}

//copy the ABI contract file into the place where the react app reads it from
async function copyContractFile(){
  copyFile(relativeAbiFilePath, relativeAbiFileNewPath, (err) => {
    if (err){
      console.log(err)
      throw err
    }
    console.log(`${relativeAbiFilePath} file was copied to ${relativeAbiFileNewPath}`);
  });
}

async function runInit(){
  const [owner, randomPerson, thirdPerson] = await ethers.getSigners();

  // Fetch initial bank balance
  let currentBalance=await provider.getBalance(bankContractObject.address);
  console.log(`Initial bank balance in ETH: ${ethers.utils.formatEther(currentBalance)} ETH`);

  
  // Fetch initial lottery balance
  // let currentLotteryBalance=await provider.getBalance(lotteryContractObject.address);
  // console.log(`Initial lottery balance in ETH: ${ethers.utils.formatEther(currentLotteryBalance)} ETH`);

  // Deposit money 
  let depositAction=await bankContractObject.connect(randomPerson).deposit({value: hre.ethers.utils.parseEther("0.1")});
  await depositAction.wait();

  // Fetch bank balance
  getBankBalance(bankContractObject);

  // Deposit money to another account
  let depositActionTo=await bankContractObject.connect(randomPerson).depositTo(thirdPerson.address,"Have some free money!",{value: ethers.utils.parseEther("0.1")});
  await depositActionTo.wait();

  // Fetch bank balance
  getBankBalance(bankContractObject);

  // Get 3rd person's balance
  let thirdPersonBalance= await bankContractObject.customerBalance(thirdPerson.address);
  console.log(`Third person balance: ${ethers.utils.formatEther(thirdPersonBalance)} ETH`)

  // Withdraw money
  let withdrawAction=await bankContractObject.connect(randomPerson).withdraw(hre.ethers.utils.parseEther("0.01"));
  await withdrawAction.wait();

  // Fetch bank balance
  getBankBalance(bankContractObject);

  // Get full transfer history
  let transferHistory= await bankContractObject.getAllTransfers();
  transferHistory.slice(0).reverse().map((transfer, index) => {
    console.log(`Listing transfer, FROM: ${transfer.depositingAccount}, TO: ${transfer.depositorAccount}, 
    MESSAGE: ${transfer.depositMessage}, AMOUNT: ${ethers.utils.formatEther(transfer.depositAmount)}, TIMESTAMP: ${new Date(transfer.timestamp*1000)}`);
  })
}

const getBankBalance = async (bankContractObject) => {
  // Fetch bank balance
  let currentBalance=await provider.getBalance(bankContractObject.address);
  console.log(`Bank balance in ETH: ${ethers.utils.formatEther(currentBalance)} ETH`);
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
const runMain = async () => {
  try {
    await deploy();
    process.exit(0);
  } catch (error) {
    console.error(error);
    process.exit(1);
  }
};

runMain();